사용자 패턴에 따라 추천 서비스가 다르다.

추천 알고리즘의 종류

1. CF (Collaborative Filtering, 협업 필터링)
 1) 종류
  - User-based: 나와 유사한 성향을 가진 사용자를 찾는 것 (개인화된 추천 가능, 이커머스에선 효과 별로 X)
  - Item-based: 보통 CF라고 하면 이것을 뜻함, 연관된 상품을 찾는 알고리즘 (이 상품을 본 사용자가 많이 본 상품, 이 상품과 연관된 상품) => 한 사람이 2가지의 상품을 봤고, 다른 사람이 같은 2가지의 상품을 봤을 때 둘 사이에 연관이 있을 것이라고 생각하는 방법

 2) 구현하는 방법
  - 매트릭스로 표현하고, 메모리에 올려서 찾는 방법
  - 사용자와 아이템을 그래프로 표현해서 분석(그래프 DB 이용)
  - 각 사용자가 본 아이템들을 페어로 묶어서 단순 카운팅 (아이템 1, 2를 본 사용자가 몇명 있는지 단순 카운팅을 해보면 두 개의 아이템이 얼마나 연관성이 있는지 알 수 있음 / 장점: 쉽게 구현 가능, 추가 피쳐를 원하는대로 추가 가능)

 3) 규모(Scalability)의 문제: 사이즈가 커지면, 메모리 부족 혹은 분석 시간이 오래걸림
  - Pre-Clustering: 유사한 특성을 가진 클러스터끼리 grouping -> 클러스터 사이즈를 줄여서 추천 시간을 줄이기 위함
    = MinHash: Hash Function(input에 대해 일관된 output을 출력하는 함수)을 사용하여 minimum값을 취하고, 같은 minimum값을 가진 아이템끼리 묶으면 공통된 특성을 가진 클러스터끼리 묶이는 것 (무선 이어폰끼리, 무선 헤드셋끼리 묶이게 됨)

 4) 단점
  - Cold Start: 신규 상품 추천X, 사용자가 보지않는 상품 추천 X
    = 해결책: CBF


2. CBF (Contents Based Filtering, 컨텐츠 기번 추천)
 - Text (컨텐츠의 종류 1): Word2Vec for Text 사용 -> 사전에 데이터를 넣기 전에 카테고리나 브랜드 등을 잘 필터링 하는 것이 원활한 추천에 도움이 됨
 - Image(컨텐츠의 종류 2): Deep Learning for Image 사용(이미지 classification) -> 유사한 스타일의 옷 찾기에서 사용됨


1+2. Hybrid: CF와 CBF 같이 사용
 - CF: 정확도가 높고 효과 좋음, 하지만 커버리지가 낮음 (약 10%밖에 커버하지 못함)
 - CBF: 커버리지가 높음 (나머지 90%를 커버)
 - CF + CBF
   = Main 알고리즘은 CF
   = CF 추천 결과가 모자란 경우 CBF로 보완
 - 패션 혹은 가구와 같은 특정 카테고리(디자인적 요소가 반영)의 경우 CBF의 효과가 더 좋을 수 있음


3. AR (Association Rule)
 1) 개념: 사용자가 구매하는 패턴을 분석하여, 연관이 있는 상품을 찾아내는 알고리즘

 2) 단점: 커버리지가 낮음 (정확하게 같이 구매한 상품만을 대상으로 하기 때문, 약 5%정도밖에 커버하지 못함)
 3) 해결책: AR(정확도 높음) + CF(커버리지 높음) -> 구매로그 기반의 CF를 사용하면 AR과 같은 효과를 얻을 수 있음



유사도 알고리즘의 종류

1. Jaccard
 1) 개념: 두 그룹 안에 얼마나 많은 공통점이 있는지를 가지고 두 그룹이 유사한지 아닌지 판단 (ex: 두 사용자가 얼마나 많은 공통된 아이템을 같이 보고 같이 구매했는지를 보고 두 사용자가 유사한지 아닌지를 판단)


2. Cosine
 1) 개념: CBF의 output이 주로 벡터값이 되므로 그 방향성이 얼마나 같은가를 체크할 수 있는 알고리즘


3. ETC: Euclidean, Manhattan, Pearson, Tanimoto



추천 시스템 아키텍쳐

1. 아키텍쳐 구조(24:42)
 User <-> API Gateway <-> Lambda -> Kinesis Firehose -> S3 -> EMR -> DynamoDB 걍 영상 봐


1-1. 최근 본 상품 구현
 User <-> API Gateway <-> Lambda <-> ElastiCache
 - API Gateway: API를 생성하고 관리해주는 서비스
 - Lambda: 서버리스 환경에서 사용자 코드를 실행해주는 서비스
  => API Gateway와 Lambada를 합치면 API 서버와 같은 기능을 함
 - ElastiCache: 사용자가 실시간으로 클릭하는 로그를 받아서 여기에 저장 가능 (인 메모리 캐시)
  => Redis를 지원해줌 -> Redis Storted Set을 지원 -> 각 유저별로 유니크한 Item Set을 저장할 수 있음, Score에는 time을 쓸 수 있음 -> 사용자가 본 아이템을 시간별로 넣게 되면 자연스럽게 sorting 되서 유니크한 타임스탭별로 모든 사용자가 최근 본 상품을 유지할 수 있게 됨
  => TTL과 Max Item 관리 가능 (얼마동안, 얼마만큼의 데이터를 유지할지 결정할 수 있음) 

이 3개면 추천 서비스를 할 수 있음


1-2. 데이터 레이크 구축 (사전 데이터 구축하기): 하나의 중앙 저장소에 모든 데이터를 저장하고, 여러 분석 트리를 이용할 수 있게 해주는 데이터 파이프라인
 ...Lambda -> Kinesis Firehose -> S3 <-> Glue
 - Kinesis Firehose: 수집된 데이터를 여기에 저장함
 - S3: 오브젝트 기반의 데이터 저장 서비스 (??? 사이즈로 잘라서 여기에 저장함)
 - Glue: Manged ETL 서비스 (추천에 필요한 데이터 포맷으로 변경하는 작업)

 1) 개념: 하나의 중앙 저장소에 모든 데이터를 저장하고 분석

 1-2) 데이터 레이크는 S3에 데이터를 저장하는 것으로 시작
 
 1-3) Glue 데이터 카탈로그는 데이터에 대한 단일 뷰를 제공 (모든 분석 툴이 하나의 데이터 저장소를 공유해서 사용할 수 있게 됨)

 2) 데이터 레이크 성능 향상 팁
  - 작은 파일 통합(512MB ~ 1GB)
  - 컬럼 포맷 사용(Parquet, ORC)
  - 압축(Snappy)
  - 파티션


1-3. 상품 추천
 ...S3 -> EMR -> DynamoDB -> 다시 Lambda
 - EMR: Managed Framework -> 내부적으로 Star Framework을 사용할 수 있고, 그 안에 ML Library가 있어서 해당 라이브러리로 손쉽게 Pre-Clustering, 추천 CF 등을 쉽게 구현 가능함
 - DynamoDB: NoSQL 기반의 데이터베이스 -> 여기에 추천 결과를 저장

사용자에게 조금 더 짧은 레이턴시로 추천 서비스를 제공하기 위하여 이런 구조를 취함 (미리 추천을 구해놓고 DynamoDB와 같은 NoSQL 기반의 데이터베이스에 저장해 놓고 바로바로 꺼내서 사용자에게 제공)



추천 시스템 아키텍쳐(상품 추천을 좀 더 쉽게 하는 버전)

1-1. SageMaker 사용 (S3에서 바로 Sagemaker로): 30:52 참고
 - 따로 서버를 만들지 않아도 됨
 - 추천 모델을 쉽게 모델링 할 수 있음(데이터가 있다면)
 - Amazon SageMaker: 데이터 과학자와 개발자들이 머신러닝 기반의 모델을 빠르고 쉽게 만들도록 해주는 완전 관리형 플랫폼 서비스
   => 개발 환경을 Notebook Instance로 제공
   => 몇가지 내장된 알고리즘이 있어서 해당 모델을 쉽게 쓸 수 있음
      => Factorization Machines이라는 추천과 관련된 모델이 있어서 데이터가 준비되면 이 모델을 사용해서 추천 서비스를 할 수 있음 (다만, 나중에는 결국 여러 알고리즘이 필요할 수 있고, 결국 아키텍쳐의 변경이 필요할 수도 있음)
   => 쉽게 모델을 트레이닝 할 수 있음
   => 학습된 모델을 도크아웃? 기반으로 배포해서 쉽게 API로 서비스까지 할 수 있는 환경 제공
      => 앞의 별도의 API 서버 만들기 등의 작업을 하지 않아도 됨



성능 평가

1. AB Test
 - On line: CTR(Click Through Ratio): 모델을 통해서 추천된 상품을 사용자들이 얼마나 많이 클릭하는가, CVR(Conversion Ratio): 클릭 후에 얼마나 구매까지 이어지는가
 - Off line: RMSE (Root Mean Squared Error): 만든 모델로 예측한 방법이 오프라인 데이터와 실제로 얼마나 많이 매핑되는지 에러율 체크

2. MAB (Multi Armed Bandit): 트래픽의 일부분을 상시 AB Test를 하는 방법 (전체 중 10%정도를 두 개의 모델로 상시 AB Test를 하고, 승자에게 나머지 트래픽 90%를 몰아주는 자동화된 방법)



추천은 UI부터 추천 알고리즘까지 유기적으로 연결해야 함 (상단에 둘 것인가, 하단에 둘 것인가 등)

실제로 추천을 사용할 땐, 이미지가 비슷한것, 타이틀이 비슷한것 등 CF가 뽑아내지 못하는 추가적인 feature들을 반영하는 작업이 필요함